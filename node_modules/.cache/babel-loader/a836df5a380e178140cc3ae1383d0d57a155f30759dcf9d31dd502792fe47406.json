{"ast":null,"code":"var z = Object.defineProperty;\nvar b = Math.pow;\nvar l = (i, e) => z(i, \"name\", {\n  value: e,\n  configurable: !0\n});\nvar m = (i, e, t) => new Promise((r, n) => {\n  var s = u => {\n      try {\n        a(t.next(u));\n      } catch (c) {\n        n(c);\n      }\n    },\n    o = u => {\n      try {\n        a(t.throw(u));\n      } catch (c) {\n        n(c);\n      }\n    },\n    a = u => u.done ? r(u.value) : Promise.resolve(u.value).then(s, o);\n  a((t = t.apply(i, e)).next());\n});\nimport { decompressSync as W } from \"fflate\";\nvar re = l((i, e) => {\n    let t = !1,\n      r = \"\",\n      n = L.GridLayer.extend({\n        createTile: l((s, o) => {\n          let a = document.createElement(\"img\"),\n            u = new AbortController(),\n            c = u.signal;\n          return a.cancel = () => {\n            u.abort();\n          }, t || (i.getHeader().then(d => {\n            d.tileType === 1 ? console.error(\"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\") : d.tileType === 2 ? r = \"image/png\" : d.tileType === 3 ? r = \"image/jpeg\" : d.tileType === 4 ? r = \"image/webp\" : d.tileType === 5 && (r = \"image/avif\");\n          }), t = !0), i.getZxy(s.z, s.x, s.y, c).then(d => {\n            if (d) {\n              let h = new Blob([d.data], {\n                  type: r\n                }),\n                p = window.URL.createObjectURL(h);\n              a.src = p, a.cancel = void 0, o(void 0, a);\n            }\n          }).catch(d => {\n            if (d.name !== \"AbortError\") throw d;\n          }), a;\n        }, \"createTile\"),\n        _removeTile: l(function (s) {\n          let o = this._tiles[s];\n          o && (o.el.cancel && o.el.cancel(), o.el.width = 0, o.el.height = 0, o.el.deleted = !0, L.DomUtil.remove(o.el), delete this._tiles[s], this.fire(\"tileunload\", {\n            tile: o.el,\n            coords: this._keyToTileCoords(s)\n          }));\n        }, \"_removeTile\")\n      });\n    return new n(e);\n  }, \"leafletRasterLayer\"),\n  j = l(i => (e, t) => {\n    if (t instanceof AbortController) return i(e, t);\n    let r = new AbortController();\n    return i(e, r).then(n => t(void 0, n.data, n.cacheControl || \"\", n.expires || \"\"), n => t(n)).catch(n => t(n)), {\n      cancel: l(() => r.abort(), \"cancel\")\n    };\n  }, \"v3compat\"),\n  T = class T {\n    constructor(e) {\n      this.tilev4 = l((e, t) => m(this, null, function* () {\n        if (e.type === \"json\") {\n          let p = e.url.substr(10),\n            y = this.tiles.get(p);\n          if (y || (y = new x(p), this.tiles.set(p, y)), this.metadata) return {\n            data: yield y.getTileJson(e.url)\n          };\n          let f = yield y.getHeader();\n          return (f.minLon >= f.maxLon || f.minLat >= f.maxLat) && console.error(`Bounds of PMTiles archive ${f.minLon},${f.minLat},${f.maxLon},${f.maxLat} are not valid.`), {\n            data: {\n              tiles: [`${e.url}/{z}/{x}/{y}`],\n              minzoom: f.minZoom,\n              maxzoom: f.maxZoom,\n              bounds: [f.minLon, f.minLat, f.maxLon, f.maxLat]\n            }\n          };\n        }\n        let r = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/),\n          n = e.url.match(r);\n        if (!n) throw new Error(\"Invalid PMTiles protocol URL\");\n        let s = n[1],\n          o = this.tiles.get(s);\n        o || (o = new x(s), this.tiles.set(s, o));\n        let a = n[2],\n          u = n[3],\n          c = n[4],\n          d = yield o.getHeader(),\n          h = yield o == null ? void 0 : o.getZxy(+a, +u, +c, t.signal);\n        if (h) return {\n          data: new Uint8Array(h.data),\n          cacheControl: h.cacheControl,\n          expires: h.expires\n        };\n        if (d.tileType === 1) {\n          if (this.errorOnMissingTile) throw new Error(\"Tile not found.\");\n          return {\n            data: new Uint8Array()\n          };\n        }\n        return {\n          data: null\n        };\n      }), \"tilev4\");\n      this.tile = j(this.tilev4);\n      this.tiles = new Map(), this.metadata = (e == null ? void 0 : e.metadata) || !1, this.errorOnMissingTile = (e == null ? void 0 : e.errorOnMissingTile) || !1;\n    }\n    add(e) {\n      this.tiles.set(e.source.getKey(), e);\n    }\n    get(e) {\n      return this.tiles.get(e);\n    }\n  };\nl(T, \"Protocol\");\nvar S = T;\nfunction w(i, e) {\n  return (e >>> 0) * 4294967296 + (i >>> 0);\n}\nl(w, \"toNum\");\nfunction F(i, e) {\n  let t = e.buf,\n    r = t[e.pos++],\n    n = (r & 112) >> 4;\n  if (r < 128 || (r = t[e.pos++], n |= (r & 127) << 3, r < 128) || (r = t[e.pos++], n |= (r & 127) << 10, r < 128) || (r = t[e.pos++], n |= (r & 127) << 17, r < 128) || (r = t[e.pos++], n |= (r & 127) << 24, r < 128) || (r = t[e.pos++], n |= (r & 1) << 31, r < 128)) return w(i, n);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\nl(F, \"readVarintRemainder\");\nfunction v(i) {\n  let e = i.buf,\n    t = e[i.pos++],\n    r = t & 127;\n  return t < 128 || (t = e[i.pos++], r |= (t & 127) << 7, t < 128) || (t = e[i.pos++], r |= (t & 127) << 14, t < 128) || (t = e[i.pos++], r |= (t & 127) << 21, t < 128) ? r : (t = e[i.pos], r |= (t & 15) << 28, F(r, i));\n}\nl(v, \"readVarint\");\nfunction k(i, e, t, r) {\n  if (r === 0) {\n    t === 1 && (e[0] = i - 1 - e[0], e[1] = i - 1 - e[1]);\n    let n = e[0];\n    e[0] = e[1], e[1] = n;\n  }\n}\nl(k, \"rotate\");\nfunction N(i, e) {\n  let t = b(2, i),\n    r = e,\n    n = e,\n    s = e,\n    o = [0, 0],\n    a = 1;\n  for (; a < t;) r = 1 & s / 2, n = 1 & (s ^ r), k(a, o, r, n), o[0] += a * r, o[1] += a * n, s = s / 4, a *= 2;\n  return [i, o[0], o[1]];\n}\nl(N, \"idOnLevel\");\nvar q = [0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405, 22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245, 91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221, 93824992236885, 375299968947541, 0x5555555555555];\nfunction G(i, e, t) {\n  if (i > 26) throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  if (e > b(2, i) - 1 || t > b(2, i) - 1) throw new Error(\"tile x/y outside zoom level bounds\");\n  let r = q[i],\n    n = b(2, i),\n    s = 0,\n    o = 0,\n    a = 0,\n    u = [e, t],\n    c = n / 2;\n  for (; c > 0;) s = (u[0] & c) > 0 ? 1 : 0, o = (u[1] & c) > 0 ? 1 : 0, a += c * c * (3 * s ^ o), k(c, u, s, o), c = c / 2;\n  return r + a;\n}\nl(G, \"zxyToTileId\");\nfunction ie(i) {\n  let e = 0,\n    t = 0;\n  for (let r = 0; r < 27; r++) {\n    let n = (1 << r) * (1 << r);\n    if (e + n > i) return N(r, i - e);\n    e += n;\n  }\n  throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\nl(ie, \"tileIdToZxy\");\nvar J = (s => (s[s.Unknown = 0] = \"Unknown\", s[s.None = 1] = \"None\", s[s.Gzip = 2] = \"Gzip\", s[s.Brotli = 3] = \"Brotli\", s[s.Zstd = 4] = \"Zstd\", s))(J || {});\nfunction D(i, e) {\n  return m(this, null, function* () {\n    if (e === 1 || e === 0) return i;\n    if (e === 2) {\n      if (typeof globalThis.DecompressionStream == \"undefined\") return W(new Uint8Array(i));\n      let t = new Response(i).body;\n      if (!t) throw new Error(\"Failed to read response stream\");\n      let r = t.pipeThrough(new globalThis.DecompressionStream(\"gzip\"));\n      return new Response(r).arrayBuffer();\n    }\n    throw new Error(\"Compression method not supported\");\n  });\n}\nl(D, \"defaultDecompress\");\nvar O = (o => (o[o.Unknown = 0] = \"Unknown\", o[o.Mvt = 1] = \"Mvt\", o[o.Png = 2] = \"Png\", o[o.Jpeg = 3] = \"Jpeg\", o[o.Webp = 4] = \"Webp\", o[o.Avif = 5] = \"Avif\", o))(O || {});\nfunction _(i) {\n  return i === 1 ? \".mvt\" : i === 2 ? \".png\" : i === 3 ? \".jpg\" : i === 4 ? \".webp\" : i === 5 ? \".avif\" : \"\";\n}\nl(_, \"tileTypeExt\");\nvar Y = 127;\nfunction Q(i, e) {\n  let t = 0,\n    r = i.length - 1;\n  for (; t <= r;) {\n    let n = r + t >> 1,\n      s = e - i[n].tileId;\n    if (s > 0) t = n + 1;else if (s < 0) r = n - 1;else return i[n];\n  }\n  return r >= 0 && (i[r].runLength === 0 || e - i[r].tileId < i[r].runLength) ? i[r] : null;\n}\nl(Q, \"findTile\");\nvar A = class A {\n  constructor(e) {\n    this.file = e;\n  }\n  getKey() {\n    return this.file.name;\n  }\n  getBytes(e, t) {\n    return m(this, null, function* () {\n      return {\n        data: yield this.file.slice(e, e + t).arrayBuffer()\n      };\n    });\n  }\n};\nl(A, \"FileSource\");\nvar V = A,\n  U = class U {\n    constructor(e, t = new Headers()) {\n      this.url = e, this.customHeaders = t, this.mustReload = !1;\n      let r = \"\";\n      \"navigator\" in globalThis && (r = globalThis.navigator.userAgent || \"\");\n      let n = r.indexOf(\"Windows\") > -1,\n        s = /Chrome|Chromium|Edg|OPR|Brave/.test(r);\n      this.chromeWindowsNoCache = !1, n && s && (this.chromeWindowsNoCache = !0);\n    }\n    getKey() {\n      return this.url;\n    }\n    setHeaders(e) {\n      this.customHeaders = e;\n    }\n    getBytes(e, t, r, n) {\n      return m(this, null, function* () {\n        let s, o;\n        r ? o = r : (s = new AbortController(), o = s.signal);\n        let a = new Headers(this.customHeaders);\n        a.set(\"range\", `bytes=${e}-${e + t - 1}`);\n        let u;\n        this.mustReload ? u = \"reload\" : this.chromeWindowsNoCache && (u = \"no-store\");\n        let c = yield fetch(this.url, {\n          signal: o,\n          cache: u,\n          headers: a\n        });\n        if (e === 0 && c.status === 416) {\n          let y = c.headers.get(\"Content-Range\");\n          if (!y || !y.startsWith(\"bytes */\")) throw new Error(\"Missing content-length on 416 response\");\n          let f = +y.substr(8);\n          c = yield fetch(this.url, {\n            signal: o,\n            cache: \"reload\",\n            headers: {\n              range: `bytes=0-${f - 1}`\n            }\n          });\n        }\n        let d = c.headers.get(\"Etag\");\n        if (d != null && d.startsWith(\"W/\") && (d = null), c.status === 416 || n && d && d !== n) throw this.mustReload = !0, new E(`Server returned non-matching ETag ${n} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);\n        if (c.status >= 300) throw new Error(`Bad response code: ${c.status}`);\n        let h = c.headers.get(\"Content-Length\");\n        if (c.status === 200 && (!h || +h > t)) throw s && s.abort(), new Error(\"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\");\n        return {\n          data: yield c.arrayBuffer(),\n          etag: d || void 0,\n          cacheControl: c.headers.get(\"Cache-Control\") || void 0,\n          expires: c.headers.get(\"Expires\") || void 0\n        };\n      });\n    }\n  };\nl(U, \"FetchSource\");\nvar C = U;\nfunction g(i, e) {\n  let t = i.getUint32(e + 4, !0),\n    r = i.getUint32(e + 0, !0);\n  return t * b(2, 32) + r;\n}\nl(g, \"getUint64\");\nfunction X(i, e) {\n  let t = new DataView(i),\n    r = t.getUint8(7);\n  if (r > 3) throw new Error(`Archive is spec version ${r} but this library supports up to spec version 3`);\n  return {\n    specVersion: r,\n    rootDirectoryOffset: g(t, 8),\n    rootDirectoryLength: g(t, 16),\n    jsonMetadataOffset: g(t, 24),\n    jsonMetadataLength: g(t, 32),\n    leafDirectoryOffset: g(t, 40),\n    leafDirectoryLength: g(t, 48),\n    tileDataOffset: g(t, 56),\n    tileDataLength: g(t, 64),\n    numAddressedTiles: g(t, 72),\n    numTileEntries: g(t, 80),\n    numTileContents: g(t, 88),\n    clustered: t.getUint8(96) === 1,\n    internalCompression: t.getUint8(97),\n    tileCompression: t.getUint8(98),\n    tileType: t.getUint8(99),\n    minZoom: t.getUint8(100),\n    maxZoom: t.getUint8(101),\n    minLon: t.getInt32(102, !0) / 1e7,\n    minLat: t.getInt32(106, !0) / 1e7,\n    maxLon: t.getInt32(110, !0) / 1e7,\n    maxLat: t.getInt32(114, !0) / 1e7,\n    centerZoom: t.getUint8(118),\n    centerLon: t.getInt32(119, !0) / 1e7,\n    centerLat: t.getInt32(123, !0) / 1e7,\n    etag: e\n  };\n}\nl(X, \"bytesToHeader\");\nfunction Z(i) {\n  let e = {\n      buf: new Uint8Array(i),\n      pos: 0\n    },\n    t = v(e),\n    r = [],\n    n = 0;\n  for (let s = 0; s < t; s++) {\n    let o = v(e);\n    r.push({\n      tileId: n + o,\n      offset: 0,\n      length: 0,\n      runLength: 1\n    }), n += o;\n  }\n  for (let s = 0; s < t; s++) r[s].runLength = v(e);\n  for (let s = 0; s < t; s++) r[s].length = v(e);\n  for (let s = 0; s < t; s++) {\n    let o = v(e);\n    o === 0 && s > 0 ? r[s].offset = r[s - 1].offset + r[s - 1].length : r[s].offset = o - 1;\n  }\n  return r;\n}\nl(Z, \"deserializeIndex\");\nvar R = class R extends Error {};\nl(R, \"EtagMismatch\");\nvar E = R;\nfunction K(i, e) {\n  return m(this, null, function* () {\n    let t = yield i.getBytes(0, 16384);\n    if (new DataView(t.data).getUint16(0, !0) !== 19792) throw new Error(\"Wrong magic number for PMTiles archive\");\n    let n = t.data.slice(0, Y),\n      s = X(n, t.etag),\n      o = t.data.slice(s.rootDirectoryOffset, s.rootDirectoryOffset + s.rootDirectoryLength),\n      a = `${i.getKey()}|${s.etag || \"\"}|${s.rootDirectoryOffset}|${s.rootDirectoryLength}`,\n      u = Z(yield e(o, s.internalCompression));\n    return [s, [a, u.length, u]];\n  });\n}\nl(K, \"getHeaderAndRoot\");\nfunction I(i, e, t, r, n) {\n  return m(this, null, function* () {\n    let s = yield i.getBytes(t, r, void 0, n.etag),\n      o = yield e(s.data, n.internalCompression),\n      a = Z(o);\n    if (a.length === 0) throw new Error(\"Empty directory is invalid\");\n    return a;\n  });\n}\nl(I, \"getDirectory\");\nvar H = class H {\n  constructor(e = 100, t = !0, r = D) {\n    this.cache = new Map(), this.maxCacheEntries = e, this.counter = 1, this.decompress = r;\n  }\n  getHeader(e) {\n    return m(this, null, function* () {\n      let t = e.getKey(),\n        r = this.cache.get(t);\n      if (r) return r.lastUsed = this.counter++, r.data;\n      let n = yield K(e, this.decompress);\n      return n[1] && this.cache.set(n[1][0], {\n        lastUsed: this.counter++,\n        data: n[1][2]\n      }), this.cache.set(t, {\n        lastUsed: this.counter++,\n        data: n[0]\n      }), this.prune(), n[0];\n    });\n  }\n  getDirectory(e, t, r, n) {\n    return m(this, null, function* () {\n      let s = `${e.getKey()}|${n.etag || \"\"}|${t}|${r}`,\n        o = this.cache.get(s);\n      if (o) return o.lastUsed = this.counter++, o.data;\n      let a = yield I(e, this.decompress, t, r, n);\n      return this.cache.set(s, {\n        lastUsed: this.counter++,\n        data: a\n      }), this.prune(), a;\n    });\n  }\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let e = 1 / 0,\n        t;\n      this.cache.forEach((r, n) => {\n        r.lastUsed < e && (e = r.lastUsed, t = n);\n      }), t && this.cache.delete(t);\n    }\n  }\n  invalidate(e) {\n    return m(this, null, function* () {\n      this.cache.delete(e.getKey());\n    });\n  }\n};\nl(H, \"ResolvedValueCache\");\nvar $ = H,\n  M = class M {\n    constructor(e = 100, t = !0, r = D) {\n      this.cache = new Map(), this.invalidations = new Map(), this.maxCacheEntries = e, this.counter = 1, this.decompress = r;\n    }\n    getHeader(e) {\n      return m(this, null, function* () {\n        let t = e.getKey(),\n          r = this.cache.get(t);\n        if (r) return r.lastUsed = this.counter++, yield r.data;\n        let n = new Promise((s, o) => {\n          K(e, this.decompress).then(a => {\n            a[1] && this.cache.set(a[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(a[1][2])\n            }), s(a[0]), this.prune();\n          }).catch(a => {\n            o(a);\n          });\n        });\n        return this.cache.set(t, {\n          lastUsed: this.counter++,\n          data: n\n        }), n;\n      });\n    }\n    getDirectory(e, t, r, n) {\n      return m(this, null, function* () {\n        let s = `${e.getKey()}|${n.etag || \"\"}|${t}|${r}`,\n          o = this.cache.get(s);\n        if (o) return o.lastUsed = this.counter++, yield o.data;\n        let a = new Promise((u, c) => {\n          I(e, this.decompress, t, r, n).then(d => {\n            u(d), this.prune();\n          }).catch(d => {\n            c(d);\n          });\n        });\n        return this.cache.set(s, {\n          lastUsed: this.counter++,\n          data: a\n        }), a;\n      });\n    }\n    prune() {\n      if (this.cache.size >= this.maxCacheEntries) {\n        let e = 1 / 0,\n          t;\n        this.cache.forEach((r, n) => {\n          r.lastUsed < e && (e = r.lastUsed, t = n);\n        }), t && this.cache.delete(t);\n      }\n    }\n    invalidate(e) {\n      return m(this, null, function* () {\n        let t = e.getKey();\n        if (this.invalidations.get(t)) return yield this.invalidations.get(t);\n        this.cache.delete(e.getKey());\n        let r = new Promise((n, s) => {\n          this.getHeader(e).then(o => {\n            n(), this.invalidations.delete(t);\n          }).catch(o => {\n            s(o);\n          });\n        });\n        this.invalidations.set(t, r);\n      });\n    }\n  };\nl(M, \"SharedPromiseCache\");\nvar P = M,\n  B = class B {\n    constructor(e, t, r) {\n      typeof e == \"string\" ? this.source = new C(e) : this.source = e, r ? this.decompress = r : this.decompress = D, t ? this.cache = t : this.cache = new P();\n    }\n    getHeader() {\n      return m(this, null, function* () {\n        return yield this.cache.getHeader(this.source);\n      });\n    }\n    getZxyAttempt(e, t, r, n) {\n      return m(this, null, function* () {\n        let s = G(e, t, r),\n          o = yield this.cache.getHeader(this.source);\n        if (e < o.minZoom || e > o.maxZoom) return;\n        let a = o.rootDirectoryOffset,\n          u = o.rootDirectoryLength;\n        for (let c = 0; c <= 3; c++) {\n          let d = yield this.cache.getDirectory(this.source, a, u, o),\n            h = Q(d, s);\n          if (h) {\n            if (h.runLength > 0) {\n              let p = yield this.source.getBytes(o.tileDataOffset + h.offset, h.length, n, o.etag);\n              return {\n                data: yield this.decompress(p.data, o.tileCompression),\n                cacheControl: p.cacheControl,\n                expires: p.expires\n              };\n            }\n            a = o.leafDirectoryOffset + h.offset, u = h.length;\n          } else return;\n        }\n        throw new Error(\"Maximum directory depth exceeded\");\n      });\n    }\n    getZxy(e, t, r, n) {\n      return m(this, null, function* () {\n        try {\n          return yield this.getZxyAttempt(e, t, r, n);\n        } catch (s) {\n          if (s instanceof E) return this.cache.invalidate(this.source), yield this.getZxyAttempt(e, t, r, n);\n          throw s;\n        }\n      });\n    }\n    getMetadataAttempt() {\n      return m(this, null, function* () {\n        let e = yield this.cache.getHeader(this.source),\n          t = yield this.source.getBytes(e.jsonMetadataOffset, e.jsonMetadataLength, void 0, e.etag),\n          r = yield this.decompress(t.data, e.internalCompression),\n          n = new TextDecoder(\"utf-8\");\n        return JSON.parse(n.decode(r));\n      });\n    }\n    getMetadata() {\n      return m(this, null, function* () {\n        try {\n          return yield this.getMetadataAttempt();\n        } catch (e) {\n          if (e instanceof E) return this.cache.invalidate(this.source), yield this.getMetadataAttempt();\n          throw e;\n        }\n      });\n    }\n    getTileJson(e) {\n      return m(this, null, function* () {\n        let t = yield this.getHeader(),\n          r = yield this.getMetadata(),\n          n = _(t.tileType);\n        return {\n          tilejson: \"3.0.0\",\n          scheme: \"xyz\",\n          tiles: [`${e}/{z}/{x}/{y}${n}`],\n          vector_layers: r.vector_layers,\n          attribution: r.attribution,\n          description: r.description,\n          name: r.name,\n          version: r.version,\n          bounds: [t.minLon, t.minLat, t.maxLon, t.maxLat],\n          center: [t.centerLon, t.centerLat, t.centerZoom],\n          minzoom: t.minZoom,\n          maxzoom: t.maxZoom\n        };\n      });\n    }\n  };\nl(B, \"PMTiles\");\nvar x = B;\nexport { J as Compression, E as EtagMismatch, C as FetchSource, V as FileSource, x as PMTiles, S as Protocol, $ as ResolvedValueCache, P as SharedPromiseCache, O as TileType, X as bytesToHeader, Q as findTile, g as getUint64, re as leafletRasterLayer, v as readVarint, ie as tileIdToZxy, _ as tileTypeExt, G as zxyToTileId };","map":{"version":3,"names":["decompressSync","W","re","l","i","e","t","r","n","L","GridLayer","extend","createTile","s","o","a","document","createElement","u","AbortController","c","signal","cancel","abort","getHeader","then","d","tileType","console","error","getZxy","z","x","y","h","Blob","data","type","p","window","URL","createObjectURL","src","catch","name","_removeTile","_tiles","el","width","height","deleted","DomUtil","remove","fire","tile","coords","_keyToTileCoords","j","cacheControl","expires","T","constructor","tilev4","m","url","substr","tiles","get","set","metadata","getTileJson","f","minLon","maxLon","minLat","maxLat","minzoom","minZoom","maxzoom","maxZoom","bounds","RegExp","match","Error","Uint8Array","errorOnMissingTile","Map","add","source","getKey","S","w","F","buf","pos","v","k","N","b","q","G","ie","J","Unknown","None","Gzip","Brotli","Zstd","D","globalThis","DecompressionStream","Response","body","pipeThrough","arrayBuffer","O","Mvt","Png","Jpeg","Webp","Avif","_","Y","Q","length","tileId","runLength","A","file","getBytes","slice","V","U","Headers","customHeaders","mustReload","navigator","userAgent","indexOf","test","chromeWindowsNoCache","setHeaders","fetch","cache","headers","status","startsWith","range","E","etag","C","g","getUint32","X","DataView","getUint8","specVersion","rootDirectoryOffset","rootDirectoryLength","jsonMetadataOffset","jsonMetadataLength","leafDirectoryOffset","leafDirectoryLength","tileDataOffset","tileDataLength","numAddressedTiles","numTileEntries","numTileContents","clustered","internalCompression","tileCompression","getInt32","centerZoom","centerLon","centerLat","Z","push","offset","R","K","getUint16","I","H","maxCacheEntries","counter","decompress","lastUsed","prune","getDirectory","size","forEach","delete","invalidate","$","M","invalidations","Promise","resolve","P","B","getZxyAttempt","getMetadataAttempt","TextDecoder","JSON","parse","decode","getMetadata","tilejson","scheme","vector_layers","attribution","description","version","center","Compression","EtagMismatch","FetchSource","FileSource","PMTiles","Protocol","ResolvedValueCache","SharedPromiseCache","TileType","bytesToHeader","findTile","getUint64","leafletRasterLayer","readVarint","tileIdToZxy","tileTypeExt","zxyToTileId"],"sources":["C:\\Users\\merce\\interactivos2\\polos_desarrollo\\node_modules\\pmtiles\\src\\index.ts","C:\\Users\\merce\\interactivos2\\polos_desarrollo\\node_modules\\pmtiles\\src\\adapters.ts"],"sourcesContent":["import { decompressSync } from \"fflate\";\nexport * from \"./adapters\";\n\n/** @hidden */\nexport interface BufferPosition {\n  buf: Uint8Array;\n  pos: number;\n}\n\nfunction toNum(low: number, high: number): number {\n  return (high >>> 0) * 0x100000000 + (low >>> 0);\n}\n\nfunction readVarintRemainder(l: number, p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 0x70) >> 4;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 3;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 10;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 17;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 24;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x01) << 31;\n  if (b < 0x80) return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\n\n/** @hidden */\nexport function readVarint(p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 0x7f;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 7;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 14;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 21;\n  if (b < 0x80) return val;\n  b = buf[p.pos];\n  val |= (b & 0x0f) << 28;\n\n  return readVarintRemainder(val, p);\n}\n\nfunction rotate(n: number, xy: number[], rx: number, ry: number): void {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\n\nfunction idOnLevel(z: number, pos: number): [number, number, number] {\n  const n = 2 ** z;\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & (t / 2);\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\n\nconst tzValues: number[] = [\n  0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405,\n  22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245,\n  91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221,\n  93824992236885, 375299968947541, 1501199875790165,\n];\n\n/**\n * Convert Z,X,Y to a Hilbert TileID.\n */\nexport function zxyToTileId(z: number, x: number, y: number): number {\n  if (z > 26) {\n    throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > 2 ** z - 1 || y > 2 ** z - 1) {\n    throw new Error(\"tile x/y outside zoom level bounds\");\n  }\n\n  const acc = tzValues[z];\n  const n = 2 ** z;\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * ((3 * rx) ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\n\n/**\n * Convert a Hilbert TileID to Z,X,Y.\n */\nexport function tileIdToZxy(i: number): [number, number, number] {\n  let acc = 0;\n  const z = 0;\n\n  for (let z = 0; z < 27; z++) {\n    const numTiles = (0x1 << z) * (0x1 << z);\n    if (acc + numTiles > i) {\n      return idOnLevel(z, i - acc);\n    }\n    acc += numTiles;\n  }\n\n  throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\n\n/**\n * PMTiles v3 directory entry.\n */\nexport interface Entry {\n  tileId: number;\n  offset: number;\n  length: number;\n  runLength: number;\n}\n\ninterface MetadataLike {\n  attribution?: string;\n  name?: string;\n  version?: string;\n  // biome-ignore lint: TileJSON spec\n  vector_layers?: string;\n  description?: string;\n}\n\n/**\n * Enum representing a compression algorithm used.\n * 0 = unknown compression, for if you must use a different or unspecified algorithm.\n * 1 = no compression.\n */\nexport enum Compression {\n  Unknown = 0,\n  None = 1,\n  Gzip = 2,\n  Brotli = 3,\n  Zstd = 4,\n}\n\n/**\n * Provide a decompression implementation that acts on `buf` and returns decompressed data.\n *\n * Should use the native DecompressionStream on browsers, zlib on node.\n * Should throw if the compression algorithm is not supported.\n */\nexport type DecompressFunc = (\n  buf: ArrayBuffer,\n  compression: Compression\n) => Promise<ArrayBuffer>;\n\nasync function defaultDecompress(\n  buf: ArrayBuffer,\n  compression: Compression\n): Promise<ArrayBuffer> {\n  if (compression === Compression.None || compression === Compression.Unknown) {\n    return buf;\n  }\n  if (compression === Compression.Gzip) {\n    // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n    if (typeof (globalThis as any).DecompressionStream === \"undefined\") {\n      return decompressSync(new Uint8Array(buf));\n    }\n    const stream = new Response(buf).body;\n    if (!stream) {\n      throw new Error(\"Failed to read response stream\");\n    }\n    const result: ReadableStream<Uint8Array> = stream.pipeThrough(\n      // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n      new (globalThis as any).DecompressionStream(\"gzip\")\n    );\n    return new Response(result).arrayBuffer();\n  }\n  throw new Error(\"Compression method not supported\");\n}\n\n/**\n * Describe the type of tiles stored in the archive.\n * 0 is unknown/other, 1 is \"MVT\" vector tiles.\n */\nexport enum TileType {\n  Unknown = 0,\n  Mvt = 1,\n  Png = 2,\n  Jpeg = 3,\n  Webp = 4,\n  Avif = 5,\n}\n\nexport function tileTypeExt(t: TileType): string {\n  if (t === TileType.Mvt) return \".mvt\";\n  if (t === TileType.Png) return \".png\";\n  if (t === TileType.Jpeg) return \".jpg\";\n  if (t === TileType.Webp) return \".webp\";\n  if (t === TileType.Avif) return \".avif\";\n  return \"\";\n}\n\nconst HEADER_SIZE_BYTES = 127;\n\n/**\n * PMTiles v3 header storing basic archive-level information.\n */\nexport interface Header {\n  specVersion: number;\n  rootDirectoryOffset: number;\n  rootDirectoryLength: number;\n  jsonMetadataOffset: number;\n  jsonMetadataLength: number;\n  leafDirectoryOffset: number;\n  leafDirectoryLength?: number;\n  tileDataOffset: number;\n  tileDataLength?: number;\n  numAddressedTiles: number;\n  numTileEntries: number;\n  numTileContents: number;\n  clustered: boolean;\n  internalCompression: Compression;\n  tileCompression: Compression;\n  tileType: TileType;\n  minZoom: number;\n  maxZoom: number;\n  minLon: number;\n  minLat: number;\n  maxLon: number;\n  maxLat: number;\n  centerZoom: number;\n  centerLon: number;\n  centerLat: number;\n  etag?: string;\n}\n\n/**\n * Low-level function for looking up a TileID or leaf directory inside a directory.\n */\nexport function findTile(entries: Entry[], tileId: number): Entry | null {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = (n + m) >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n\n  // at this point, m > n\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\n\nexport interface RangeResponse {\n  data: ArrayBuffer;\n  etag?: string;\n  expires?: string;\n  cacheControl?: string;\n}\n\n/**\n * Interface for retrieving an archive from remote or local storage.\n */\nexport interface Source {\n  getBytes: (\n    offset: number,\n    length: number,\n    signal?: AbortSignal,\n    etag?: string\n  ) => Promise<RangeResponse>;\n\n  /**\n   * Return a unique string key for the archive e.g. a URL.\n   */\n  getKey: () => string;\n}\n\n/**\n * Use the Browser's File API, which is different from the NodeJS file API.\n * see https://developer.mozilla.org/en-US/docs/Web/API/File_API\n */\nexport class FileSource implements Source {\n  file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  getKey() {\n    return this.file.name;\n  }\n\n  async getBytes(offset: number, length: number): Promise<RangeResponse> {\n    const blob = this.file.slice(offset, offset + length);\n    const a = await blob.arrayBuffer();\n    return { data: a };\n  }\n}\n\n/**\n * Uses the browser Fetch API to make tile requests via HTTP.\n *\n * This method does not send conditional request headers If-Match because of CORS.\n * Instead, it detects ETag mismatches via the response ETag or the 416 response code.\n *\n * This also works around browser and storage-specific edge cases.\n */\nexport class FetchSource implements Source {\n  url: string;\n\n  /**\n   * A [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, specfying custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   *\n   * This should be used instead of maplibre's [transformRequest](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#example) for PMTiles archives.\n   */\n  customHeaders: Headers;\n  /** @hidden */\n  mustReload: boolean;\n  /** @hidden */\n  chromeWindowsNoCache: boolean;\n\n  constructor(url: string, customHeaders: Headers = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n    let userAgent = \"\";\n    if (\"navigator\" in globalThis) {\n      //biome-ignore lint: cf workers\n      userAgent = (globalThis as any).navigator.userAgent || \"\";\n    }\n    const isWindows = userAgent.indexOf(\"Windows\") > -1;\n    const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);\n    this.chromeWindowsNoCache = false;\n    if (isWindows && isChromiumBased) {\n      this.chromeWindowsNoCache = true;\n    }\n  }\n\n  getKey() {\n    return this.url;\n  }\n\n  /**\n   * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   */\n  setHeaders(customHeaders: Headers) {\n    this.customHeaders = customHeaders;\n  }\n\n  async getBytes(\n    offset: number,\n    length: number,\n    passedSignal?: AbortSignal,\n    etag?: string\n  ): Promise<RangeResponse> {\n    let controller: AbortController | undefined;\n    let signal: AbortSignal | undefined;\n    if (passedSignal) {\n      signal = passedSignal;\n    } else {\n      controller = new AbortController();\n      signal = controller.signal;\n    }\n\n    const requestHeaders = new Headers(this.customHeaders);\n    requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n\n    // we don't send if match because:\n    // * it disables browser caching completely (Chromium)\n    // * it requires a preflight request for every tile request\n    // * it requires CORS configuration becasue If-Match is not a CORs-safelisted header\n    // CORs configuration should expose ETag.\n    // if any etag mismatch is detected, we need to ignore the browser cache\n    let cache: string | undefined;\n    if (this.mustReload) {\n      cache = \"reload\";\n    } else if (this.chromeWindowsNoCache) {\n      cache = \"no-store\";\n    }\n\n    let resp = await fetch(this.url, {\n      signal: signal,\n      cache: cache,\n      headers: requestHeaders,\n      //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n    } as any);\n\n    // handle edge case where the archive is < 16384 kb total.\n    if (offset === 0 && resp.status === 416) {\n      const contentRange = resp.headers.get(\"Content-Range\");\n      if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n        throw new Error(\"Missing content-length on 416 response\");\n      }\n      const actualLength = +contentRange.substr(8);\n      resp = await fetch(this.url, {\n        signal: signal,\n        cache: \"reload\",\n        headers: { range: `bytes=0-${actualLength - 1}` },\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      } as any);\n    }\n\n    // if it's a weak etag, it's not useful for us, so ignore it.\n    let newEtag = resp.headers.get(\"Etag\");\n    if (newEtag?.startsWith(\"W/\")) {\n      newEtag = null;\n    }\n\n    // some storage systems are misbehaved (Cloudflare R2)\n    if (resp.status === 416 || (etag && newEtag && newEtag !== etag)) {\n      this.mustReload = true;\n      throw new EtagMismatch(\n        `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n      );\n    }\n\n    if (resp.status >= 300) {\n      throw new Error(`Bad response code: ${resp.status}`);\n    }\n\n    // some well-behaved backends, e.g. DigitalOcean CDN, respond with 200 instead of 206\n    // but we also need to detect no support for Byte Serving which is returning the whole file\n    const contentLength = resp.headers.get(\"Content-Length\");\n    if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n      if (controller) controller.abort();\n      throw new Error(\n        \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n      );\n    }\n\n    const a = await resp.arrayBuffer();\n    return {\n      data: a,\n      etag: newEtag || undefined,\n      cacheControl: resp.headers.get(\"Cache-Control\") || undefined,\n      expires: resp.headers.get(\"Expires\") || undefined,\n    };\n  }\n}\n\n/** @hidden */\nexport function getUint64(v: DataView, offset: number): number {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * 2 ** 32 + wl;\n}\n\n/**\n * Parse raw header bytes into a Header object.\n */\nexport function bytesToHeader(bytes: ArrayBuffer, etag?: string): Header {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw new Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n\n  return {\n    specVersion: specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 10000000,\n    minLat: v.getInt32(106, true) / 10000000,\n    maxLon: v.getInt32(110, true) / 10000000,\n    maxLat: v.getInt32(114, true) / 10000000,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 10000000,\n    centerLat: v.getInt32(123, true) / 10000000,\n    etag: etag,\n  };\n}\n\nfunction deserializeIndex(buffer: ArrayBuffer): Entry[] {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n\n  const entries: Entry[] = [];\n\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n\n  return entries;\n}\n\nfunction detectVersion(a: ArrayBuffer): number {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.error(\n      \"PMTiles spec version 2 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.error(\n      \"PMTiles spec version 1 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\n\n/**\n * Error thrown when a response for PMTiles over HTTP does not match previous, cached parts of the archive.\n * The default PMTiles implementation will catch this error once internally and retry a request.\n */\nexport class EtagMismatch extends Error {}\n\n/**\n * Interface for caches of parts (headers, directories) of a PMTiles archive.\n */\nexport interface Cache {\n  getHeader: (source: Source) => Promise<Header>;\n  getDirectory: (\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ) => Promise<Entry[]>;\n  invalidate: (source: Source) => Promise<void>;\n}\n\nasync function getHeaderAndRoot(\n  source: Source,\n  decompress: DecompressFunc\n): Promise<[Header, [string, number, Entry[] | ArrayBuffer]?]> {\n  const resp = await source.getBytes(0, 16384);\n\n  const v = new DataView(resp.data);\n  if (v.getUint16(0, true) !== 0x4d50) {\n    throw new Error(\"Wrong magic number for PMTiles archive\");\n  }\n\n  const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n\n  const header = bytesToHeader(headerData, resp.etag);\n\n  // optimistically set the root directory\n  // TODO check root bounds\n  const rootDirData = resp.data.slice(\n    header.rootDirectoryOffset,\n    header.rootDirectoryOffset + header.rootDirectoryLength\n  );\n  const dirKey = `${source.getKey()}|${header.etag || \"\"}|${\n    header.rootDirectoryOffset\n  }|${header.rootDirectoryLength}`;\n\n  const rootDir = deserializeIndex(\n    await decompress(rootDirData, header.internalCompression)\n  );\n  return [header, [dirKey, rootDir.length, rootDir]];\n}\n\nasync function getDirectory(\n  source: Source,\n  decompress: DecompressFunc,\n  offset: number,\n  length: number,\n  header: Header\n): Promise<Entry[]> {\n  const resp = await source.getBytes(offset, length, undefined, header.etag);\n  const data = await decompress(resp.data, header.internalCompression);\n  const directory = deserializeIndex(data);\n  if (directory.length === 0) {\n    throw new Error(\"Empty directory is invalid\");\n  }\n\n  return directory;\n}\n\ninterface ResolvedValue {\n  lastUsed: number;\n  data: Header | Entry[] | ArrayBuffer;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises are never shared between requests.\n *\n * Runtimes such as Cloudflare Workers cannot share promises between different requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class ResolvedValueCache {\n  cache: Map<string, ResolvedValue>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, ResolvedValue>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Header;\n    }\n\n    const res = await getHeaderAndRoot(source, this.decompress);\n    if (res[1]) {\n      this.cache.set(res[1][0], {\n        lastUsed: this.counter++,\n        data: res[1][2],\n      });\n    }\n\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: res[0],\n    });\n    this.prune();\n    return res[0];\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Entry[];\n    }\n\n    const directory = await getDirectory(\n      source,\n      this.decompress,\n      offset,\n      length,\n      header\n    );\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: directory,\n    });\n    this.prune();\n    return directory;\n  }\n\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: ResolvedValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    this.cache.delete(source.getKey());\n  }\n}\n\ninterface SharedPromiseCacheValue {\n  lastUsed: number;\n  data: Promise<Header | Entry[] | ArrayBuffer>;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises can be shared between requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class SharedPromiseCache {\n  cache: Map<string, SharedPromiseCacheValue>;\n  invalidations: Map<string, Promise<void>>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, SharedPromiseCacheValue>();\n    this.invalidations = new Map<string, Promise<void>>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Header;\n    }\n\n    const p = new Promise<Header>((resolve, reject) => {\n      getHeaderAndRoot(source, this.decompress)\n        .then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2]),\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Entry[];\n    }\n\n    const p = new Promise<Entry[]>((resolve, reject) => {\n      getDirectory(source, this.decompress, offset, length, header)\n        .then((directory) => {\n          resolve(directory);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: SharedPromiseCacheValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    const key = source.getKey();\n    if (this.invalidations.get(key)) {\n      return await this.invalidations.get(key);\n    }\n    this.cache.delete(source.getKey());\n    const p = new Promise<void>((resolve, reject) => {\n      this.getHeader(source)\n        .then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.invalidations.set(key, p);\n  }\n}\n\n/**\n * Main class encapsulating PMTiles decoding logic.\n *\n * if `source` is a string, creates a FetchSource using that string as the URL to a remote PMTiles.\n * if no `cache` is passed, use a SharedPromiseCache.\n * if no `decompress` is passed, default to the browser DecompressionStream API with a fallback to `fflate`.\n */\n// biome-ignore lint: that's just how its capitalized\nexport class PMTiles {\n  source: Source;\n  cache: Cache;\n  decompress: DecompressFunc;\n\n  constructor(\n    source: Source | string,\n    cache?: Cache,\n    decompress?: DecompressFunc\n  ) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  async getHeader() {\n    return await this.cache.getHeader(this.source);\n  }\n\n  /** @hidden */\n  async getZxyAttempt(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    const tileId = zxyToTileId(z, x, y);\n    const header = await this.cache.getHeader(this.source);\n\n    if (z < header.minZoom || z > header.maxZoom) {\n      return undefined;\n    }\n\n    let dO = header.rootDirectoryOffset;\n    let dL = header.rootDirectoryLength;\n    for (let depth = 0; depth <= 3; depth++) {\n      const directory = await this.cache.getDirectory(\n        this.source,\n        dO,\n        dL,\n        header\n      );\n      const entry = findTile(directory, tileId);\n      if (entry) {\n        if (entry.runLength > 0) {\n          const resp = await this.source.getBytes(\n            header.tileDataOffset + entry.offset,\n            entry.length,\n            signal,\n            header.etag\n          );\n          return {\n            data: await this.decompress(resp.data, header.tileCompression),\n            cacheControl: resp.cacheControl,\n            expires: resp.expires,\n          };\n        }\n        dO = header.leafDirectoryOffset + entry.offset;\n        dL = entry.length;\n      } else {\n        // TODO: We should in fact return a valid RangeResponse\n        // with empty data, but filled in cache control / expires headers\n        return undefined;\n      }\n    }\n    throw new Error(\"Maximum directory depth exceeded\");\n  }\n\n  /**\n   * Primary method to get a single tile's bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  async getZxy(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    try {\n      return await this.getZxyAttempt(z, x, y, signal);\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getZxyAttempt(z, x, y, signal);\n      }\n      throw e;\n    }\n  }\n\n  /** @hidden */\n  async getMetadataAttempt(): Promise<unknown> {\n    const header = await this.cache.getHeader(this.source);\n\n    const resp = await this.source.getBytes(\n      header.jsonMetadataOffset,\n      header.jsonMetadataLength,\n      undefined,\n      header.etag\n    );\n    const decompressed = await this.decompress(\n      resp.data,\n      header.internalCompression\n    );\n    const dec = new TextDecoder(\"utf-8\");\n    return JSON.parse(dec.decode(decompressed));\n  }\n\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  async getMetadata(): Promise<unknown> {\n    try {\n      return await this.getMetadataAttempt();\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getMetadataAttempt();\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.\n   *\n   * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.\n   * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,\n   * the baseTilesUrl should be `https://example.com/tileset`.\n   */\n  async getTileJson(baseTilesUrl: string): Promise<unknown> {\n    const header = await this.getHeader();\n    const metadata = (await this.getMetadata()) as MetadataLike;\n    const ext = tileTypeExt(header.tileType);\n\n    return {\n      tilejson: \"3.0.0\",\n      scheme: \"xyz\",\n      tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],\n      // biome-ignore lint: TileJSON spec\n      vector_layers: metadata.vector_layers,\n      attribution: metadata.attribution,\n      description: metadata.description,\n      name: metadata.name,\n      version: metadata.version,\n      bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],\n      center: [header.centerLon, header.centerLat, header.centerZoom],\n      minzoom: header.minZoom,\n      maxzoom: header.maxZoom,\n    };\n  }\n}\n","// biome-ignore lint: needed for Leaflet + IIFE to work\ndeclare const L: any;\n// biome-ignore lint: needed for window.URL to disambiguate from cloudflare workers\ndeclare const window: any;\ndeclare const document: DocumentLike;\n\nimport type { Coords } from \"leaflet\";\nimport { PMTiles, TileType } from \"./index\";\n\ninterface DocumentLike {\n  // biome-ignore lint: we don't want to bring in the entire document type\n  createElement: (s: string) => any;\n}\n\n// biome-ignore lint: we don't want to bring in the entire document type\ntype DoneCallback = (error?: Error, tile?: any) => void;\n\n/**\n * Add a raster PMTiles as a layer to a Leaflet map.\n *\n * For vector tiles see https://github.com/protomaps/protomaps-leaflet\n */\nexport const leafletRasterLayer = (source: PMTiles, options: unknown) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord: Coords, done: DoneCallback) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === TileType.Mvt) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source\n        .getZxy(coord.z, coord.x, coord.y, signal)\n        .then((arr) => {\n          if (arr) {\n            const blob = new Blob([arr.data], { type: mimeType });\n            const imageUrl = window.URL.createObjectURL(blob);\n            el.src = imageUrl;\n            el.cancel = undefined;\n            done(undefined, el);\n          }\n        })\n        .catch((e) => {\n          if (e.name !== \"AbortError\") {\n            throw e;\n          }\n        });\n      return el;\n    },\n\n    _removeTile: function (key: string) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      if (tile.el.cancel) tile.el.cancel();\n\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key),\n      });\n    },\n  });\n  return new cls(options);\n};\n\ntype GetResourceResponse<T> = ExpiryData & {\n  data: T;\n};\ntype AddProtocolAction = (\n  requestParameters: RequestParameters,\n  abortController: AbortController\n) => Promise<GetResourceResponse<unknown>>;\n\ntype ExpiryData = {\n  cacheControl?: string | null;\n  expires?: string | null; // MapLibre can be a Date object\n};\n\n// copied from MapLibre /util/ajax.ts\ntype RequestParameters = {\n  url: string;\n  headers?: unknown;\n  method?: \"GET\" | \"POST\" | \"PUT\";\n  body?: string;\n  type?: \"string\" | \"json\" | \"arrayBuffer\" | \"image\";\n  credentials?: \"same-origin\" | \"include\";\n  collectResourceTiming?: boolean;\n};\n\n// for legacy maplibre-3 interop\ntype ResponseCallbackV3 = (\n  error?: Error | undefined,\n  data?: unknown | undefined,\n  cacheControl?: string | undefined,\n  expires?: string | undefined\n) => void;\n\ntype V3OrV4Protocol = <\n  T extends AbortController | ResponseCallbackV3,\n  R = T extends AbortController\n    ? Promise<GetResourceResponse<unknown>>\n    : { cancel: () => void },\n>(\n  requestParameters: RequestParameters,\n  arg2: T\n) => R;\n\nconst v3compat =\n  (v4: AddProtocolAction): V3OrV4Protocol =>\n  (requestParameters, arg2) => {\n    if (arg2 instanceof AbortController) {\n      // biome-ignore lint: overloading return type not handled by compiler\n      return v4(requestParameters, arg2) as any;\n    }\n    const abortController = new AbortController();\n    v4(requestParameters, abortController)\n      .then(\n        (result) => {\n          return arg2(\n            undefined,\n            result.data,\n            result.cacheControl || \"\",\n            result.expires || \"\"\n          );\n        },\n        (err) => {\n          return arg2(err);\n        }\n      )\n      .catch((e) => {\n        return arg2(e);\n      });\n    return { cancel: () => abortController.abort() };\n  };\n\n/**\n * MapLibre GL JS protocol. Must be added once globally.\n */\nexport class Protocol {\n  /** @hidden */\n  tiles: Map<string, PMTiles>;\n  metadata: boolean;\n  errorOnMissingTile: boolean;\n\n  /**\n   * Initialize the MapLibre PMTiles protocol.\n   *\n   * * metadata: also load the metadata section of the PMTiles. required for some \"inspect\" functionality\n   * and to automatically populate the map attribution. Requires an extra HTTP request.\n   * * errorOnMissingTile: When a vector MVT tile is missing from the archive, raise an error instead of\n   * returning the empty array. Not recommended. This is only to reproduce the behavior of ZXY tile APIs\n   * which some applications depend on when overzooming.\n   */\n  constructor(options?: { metadata?: boolean; errorOnMissingTile?: boolean }) {\n    this.tiles = new Map<string, PMTiles>();\n    this.metadata = options?.metadata || false;\n    this.errorOnMissingTile = options?.errorOnMissingTile || false;\n  }\n\n  /**\n   * Add a {@link PMTiles} instance to the global protocol instance.\n   *\n   * For remote fetch sources, references in MapLibre styles like pmtiles://http://...\n   * will resolve to the same instance if the URLs match.\n   */\n  add(p: PMTiles) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n\n  /**\n   * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.\n   */\n  get(url: string) {\n    return this.tiles.get(url);\n  }\n\n  /** @hidden */\n  tilev4 = async (\n    params: RequestParameters,\n    abortController: AbortController\n  ) => {\n    if (params.type === \"json\") {\n      const pmtilesUrl = params.url.substr(10);\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n\n      if (this.metadata) {\n        return {\n          data: await instance.getTileJson(params.url),\n        };\n      }\n\n      const h = await instance.getHeader();\n\n      if (h.minLon >= h.maxLon || h.minLat >= h.maxLat) {\n        console.error(\n          `Bounds of PMTiles archive ${h.minLon},${h.minLat},${h.maxLon},${h.maxLat} are not valid.`\n        );\n      }\n\n      return {\n        data: {\n          tiles: [`${params.url}/{z}/{x}/{y}`],\n          minzoom: h.minZoom,\n          maxzoom: h.maxZoom,\n          bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat],\n        },\n      };\n    }\n    const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n    const result = params.url.match(re);\n    if (!result) {\n      throw new Error(\"Invalid PMTiles protocol URL\");\n    }\n    const pmtilesUrl = result[1];\n\n    let instance = this.tiles.get(pmtilesUrl);\n    if (!instance) {\n      instance = new PMTiles(pmtilesUrl);\n      this.tiles.set(pmtilesUrl, instance);\n    }\n    const z = result[2];\n    const x = result[3];\n    const y = result[4];\n\n    const header = await instance.getHeader();\n    const resp = await instance?.getZxy(+z, +x, +y, abortController.signal);\n    if (resp) {\n      return {\n        data: new Uint8Array(resp.data),\n        cacheControl: resp.cacheControl,\n        expires: resp.expires,\n      };\n    }\n    if (header.tileType === TileType.Mvt) {\n      if (this.errorOnMissingTile) {\n        throw new Error(\"Tile not found.\");\n      }\n      return { data: new Uint8Array() };\n    }\n    return { data: null };\n  };\n\n  tile = v3compat(this.tilev4);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}